# MySQL基础
## <font style="color:rgb(44, 62, 80);">执行一条 select 语句，期间发生了什么？</font>
![](https://cdn.nlark.com/yuque/0/2025/png/39185937/1735982642578-663273aa-8eff-4c87-abee-9941a112e009.png)

从上图可以看出， MySQL 主要由下面几部分构成：

+ **连接器：** 身份认证和权限相关(登录 MySQL 的时候)。
+ **查询缓存：** 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。
+ **分析器：** 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。
+ **优化器：** 按照 MySQL 认为最优的方案去执行。
+ **执行器：** 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。
+ **插件式存储引擎**：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。InnoDB 是 MySQL 的默认存储引擎，绝大部分场景使用 InnoDB 就是最好的选择。

# MySQL索引
# 索引介绍
**索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。**

索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。

索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。

## 索引类型总结
**按照数据结构维度划分：**

+ BTree 索引：MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不一样（前面已经介绍了）。
+ 哈希索引：类似键值对的形式，一次即可定位。
+ RTree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。
+ 全文索引：对文本的内容进行分词，进行搜索。目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。

**按照底层存储方式角度划分：**

+ 聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。
+ 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。

**按照应用维度划分：**

+ 主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。
+ 普通索引：仅加速查询。
+ 唯一索引：加速查询 + 列值唯一（可以有 NULL）。
+ 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。
+ 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。
+ 全文索引：对文本的内容进行分词，进行搜索。目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。
+ 前缀索引：对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。

## 为什么使用B+树作为索引
**个人观点：javaGuide总结了很多其他数据结构的不足，但是我认为其实用两句话就可以总结为什么用B+树：**

+ **因为B+树的非叶子节点不用存储数据，B+树用更少的层数（也就是更少的磁盘IO）就能查询到更多的数据。**
+ **B+树的叶子节点用双向链表连接，更方便范围查询**

## 什么时候适用索引
+ 字段有唯一性的
+ 经常用于where查询的字段
+ 经常用于group by和 order by 的字段

## 什么时候不需要索引
+ where、group by里面用不到的字段
+ 字段内有大量重复数据，区分度不高的
+ 表数据比较少
+ 经常更新的字段

## 正确使用索引的一些建议
### 选择合适的字段创建索引
+ **不为 NULL 的字段**：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。
+ **被频繁查询的字段**：我们创建索引的字段应该是查询操作非常频繁的字段。
+ **被作为条件查询的字段**：被作为 WHERE 条件查询的字段，应该被考虑建立索引。
+ **频繁需要排序的字段**：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
+ **被经常频繁用于连接的字段**：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。

### 被频繁更新的字段应该慎重建立索引
虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。

### 限制每张表上的索引数量
索引并不是越多越好，建议单张表索引不超过 5 个！索引可以提高效率同样可以降低效率。

索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。

因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。

### 尽可能的考虑建立联合索引而不是单列索引
因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。

### 注意避免冗余索引
冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。

### 字符串类型的字段使用前缀索引代替普通索引
前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。

### 避免索引失效
索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：

+ ~~使用 ~~`~~SELECT *~~`~~ 进行查询;~~`SELECT *` 不会直接导致索引失效（如果不走索引大概率是因为 where 查询范围过大导致的），但它可能会带来一些其他的性能问题比如造成网络传输和数据处理的浪费、无法使用索引覆盖;
+ 创建了组合索引，但查询条件未遵守最左匹配原则;
+ 在索引列上进行计算、函数、类型转换等操作;
+ 以 % 开头的 LIKE 查询比如 `LIKE '%abc';`;
+ 查询条件中使用 OR，且 OR 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;
+ IN 的取值范围较大时会导致索引失效，走全表扫描(NOT IN 和 IN 的失效场景相同);
+ 发生[隐式转换](https://javaguide.cn/database/mysql/index-invalidation-caused-by-implicit-conversion.html);
+ ……

### 删除长期未使用的索引
删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。

MySQL 5.7 可以通过查询 `sys` 库的 `schema_unused_indexes` 视图来查询哪些索引从未被使用。

## 哪种count性能最好？
![](https://cdn.nlark.com/yuque/0/2025/png/39185937/1736001211921-8ee4bceb-a755-4a2b-a44d-8326488ee136.png)

# MySQL事务
# MySQL锁
# MySQL日志
