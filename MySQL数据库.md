# MySQL基础
## <font style="color:rgb(44, 62, 80);">执行一条 select 语句，期间发生了什么？</font>
![](https://cdn.nlark.com/yuque/0/2025/png/39185937/1735982642578-663273aa-8eff-4c87-abee-9941a112e009.png)

从上图可以看出， MySQL 主要由下面几部分构成：

+ **连接器：** 身份认证和权限相关(登录 MySQL 的时候)。
+ **查询缓存：** 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。
+ **分析器：** 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。
+ **优化器：** 按照 MySQL 认为最优的方案去执行。
+ **执行器：** 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。
+ **插件式存储引擎**：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。InnoDB 是 MySQL 的默认存储引擎，绝大部分场景使用 InnoDB 就是最好的选择。

# MySQL索引
## 索引介绍
**索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。**

索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。

索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。

## 索引类型总结
**按照数据结构维度划分：**

+ BTree 索引：MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不一样（前面已经介绍了）。
+ 哈希索引：类似键值对的形式，一次即可定位。
+ RTree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。
+ 全文索引：对文本的内容进行分词，进行搜索。目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。

**按照底层存储方式角度划分：**

+ 聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。
+ 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。

**按照应用维度划分：**

+ 主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。
+ 普通索引：仅加速查询。
+ 唯一索引：加速查询 + 列值唯一（可以有 NULL）。
+ 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。
+ 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。
+ 全文索引：对文本的内容进行分词，进行搜索。目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。
+ 前缀索引：对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。

## 为什么使用B+树作为索引
**个人观点：javaGuide总结了很多其他数据结构的不足，但是我认为其实用两句话就可以总结为什么用B+树：**

+ **因为B+树的非叶子节点不用存储数据，B+树用更少的层数（也就是更少的磁盘IO）就能查询到更多的数据。**
+ **B+树的叶子节点用双向链表连接，更方便范围查询**

## 什么时候适用索引
+ 字段有唯一性的
+ 经常用于where查询的字段
+ 经常用于group by和 order by 的字段

## 什么时候不需要索引
+ where、group by里面用不到的字段
+ 字段内有大量重复数据，区分度不高的
+ 表数据比较少
+ 经常更新的字段

## 正确使用索引的一些建议
### 选择合适的字段创建索引
+ **不为 NULL 的字段**：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。
+ **被频繁查询的字段**：我们创建索引的字段应该是查询操作非常频繁的字段。
+ **被作为条件查询的字段**：被作为 WHERE 条件查询的字段，应该被考虑建立索引。
+ **频繁需要排序的字段**：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
+ **被经常频繁用于连接的字段**：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。

### 被频繁更新的字段应该慎重建立索引
虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。

### 限制每张表上的索引数量
索引并不是越多越好，建议单张表索引不超过 5 个！索引可以提高效率同样可以降低效率。

索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。

因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。

### 尽可能的考虑建立联合索引而不是单列索引
因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。

### 注意避免冗余索引
冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。

### 字符串类型的字段使用前缀索引代替普通索引
前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。

### 避免索引失效
索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：

+ ~~使用 ~~`~~SELECT *~~`~~ 进行查询;~~`SELECT *` 不会直接导致索引失效（如果不走索引大概率是因为 where 查询范围过大导致的），但它可能会带来一些其他的性能问题比如造成网络传输和数据处理的浪费、无法使用索引覆盖;
+ 创建了组合索引，但查询条件未遵守最左匹配原则;
+ 在索引列上进行计算、函数、类型转换等操作;
+ 以 % 开头的 LIKE 查询比如 `LIKE '%abc';`;
+ 查询条件中使用 OR，且 OR 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;
+ IN 的取值范围较大时会导致索引失效，走全表扫描(NOT IN 和 IN 的失效场景相同);
+ 发生[隐式转换](https://javaguide.cn/database/mysql/index-invalidation-caused-by-implicit-conversion.html);
+ ……

### 删除长期未使用的索引
删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。

MySQL 5.7 可以通过查询 `sys` 库的 `schema_unused_indexes` 视图来查询哪些索引从未被使用。

## 哪种count性能最好？
![](https://cdn.nlark.com/yuque/0/2025/png/39185937/1736001211921-8ee4bceb-a755-4a2b-a44d-8326488ee136.png)

# MySQL事务
## 事务的四大特性
1. 原子性（`Atomicity`）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；**（undo log回滚日志）**
2. 一致性（`Consistency`）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
3. 隔离性（`Isolation`）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；**（MVCC+锁）**
4. 持久性（`Durability`）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。**（redo log重做日志）**

🌈 这里要额外补充一点：只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！

## <font style="color:rgb(60, 60, 67);">并发事务带来了哪些问题?</font>
### 脏读（Dirty read）
一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。

### 丢失修改（Lost to modify）
在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。

### 不可重复读（Unrepeatable read）
指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

### 幻读（Phantom read）
幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

## 事务的隔离级别
+ **READ-UNCOMMITTED(读取未提交)** ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
+ **READ-COMMITTED(读取已提交)** ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
+ **REPEATABLE-READ(可重复读)** ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
+ **SERIALIZABLE(可串行化)** ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

### InnoDb引擎的可重复读级别可以解决部分幻读问题
+ 针对快照读通过MVCC
+ 针对当前读使用临建锁

**先使用快照读，其他事务修改数据后使用当前读会出现幻读**

## InnoDB 对 MVCC 的实现
`MVCC` 的实现依赖于：隐藏字段、Read View、undo log。在内部实现中，`InnoDB` 通过数据行的 `DB_TRX_ID（上一次操作数据的事务id）` 和 `Read View` 来判断数据的可见性，如不可见，则通过数据行的 `DB_ROLL_PTR（回滚指针）` 找到 `undo log` 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 `Read View` 之前已经提交的修改和该事务本身做的修改

### 隐藏字段
在内部，`InnoDB` 存储引擎为每行数据添加了三个 [隐藏字段](https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html)：

+ `DB_TRX_ID（6字节）`：表示最后一次插入或更新该行的事务 id。此外，`delete` 操作在内部被视为更新，只不过会在记录头 `Record header` 中的 `deleted_flag` 字段将其标记为已删除
+ `DB_ROLL_PTR（7字节）` 回滚指针，指向该行的 `undo log` 。如果该行未被更新，则为空
+ `DB_ROW_ID（6字节）`：如果没有设置主键且该表没有唯一非空索引时，`InnoDB` 会使用该 id 来生成聚簇索引

### ReadView
```plain
class ReadView {
  /* ... */
private:
  trx_id_t m_low_limit_id;      /* 大于等于这个 ID 的事务均不可见 */

  trx_id_t m_up_limit_id;       /* 小于这个 ID 的事务均可见 */

  trx_id_t m_creator_trx_id;    /* 创建该 Read View 的事务ID */

  trx_id_t m_low_limit_no;      /* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */

  ids_t m_ids;                  /* 创建 Read View 时的活跃事务列表 */

  m_closed;                     /* 标记 Read View 是否 close */
}
```

Read View 主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务”

主要有以下字段：

+ `m_low_limit_id`：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见
+ `m_up_limit_id`：活跃事务列表 `m_ids` 中最小的事务 ID，如果 `m_ids` 为空，则 `m_up_limit_id` 为 `m_low_limit_id`。小于这个 ID 的数据版本均可见
+ `m_ids`：`Read View` 创建时其他未提交的活跃事务 ID 列表。创建 `Read View`时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。`m_ids` 不包括当前事务自己和已提交的事务（正在内存中）
+ `m_creator_trx_id`：创建该 `Read View` 的事务 ID

**事务可见性示意图**：

![](https://cdn.nlark.com/yuque/0/2025/png/39185937/1736051751492-76693550-92c7-4219-9cbe-ce2b66e0444d.png)

### undo-log
`undo log` 主要有两个作用：

+ 当事务回滚时用于将数据恢复到修改前的样子
+ 另一个作用是 `MVCC` ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 `undo log` 读取之前的版本数据，以此实现非锁定读

### 数据可见性算法
在 `InnoDB` 存储引擎中，创建一个新事务后，执行每个 `select` 语句前，都会创建一个快照（Read View），**快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号**。其实简单的说保存的是系统中当前不应该被本事务看到的其他事务 ID 列表（即 m_ids）。当用户在这个事务中要读取某个记录行的时候，`InnoDB` 会将该记录行的 `DB_TRX_ID` 与 `Read View` 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件

具体的比较算法如下：

![](https://cdn.nlark.com/yuque/0/2025/png/39185937/1736051853690-743c6fd0-fc1f-4e86-925b-5bc543b6a161.png)

1. 如果记录 DB_TRX_ID < m_up_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是可见的
2. 如果 DB_TRX_ID >= m_low_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤 5
3. m_ids 为空，则表明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的
4. 如果 m_up_limit_id <= DB_TRX_ID < m_low_limit_id，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 m_ids 进行查找（源码中是用的二分查找，因为是有序的）
    - 如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务创建快照前，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了，但没有提交；或者 ② 在当前事务创建快照后，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。跳到步骤 5
    - 在活跃事务列表中找不到，则表明“id 为 trx_id 的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见
5. 在该记录行的 DB_ROLL_PTR 指针所指向的 `undo log` 取出快照记录，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到满足的快照版本或返回空

## RC 和 RR 隔离级别下 MVCC 的差异
在事务隔离级别 `RC` 和 `RR` （InnoDB 存储引擎的默认事务隔离级别）下，`InnoDB` 存储引擎使用 `MVCC`（非锁定一致性读），但它们生成 `Read View` 的时机却不同

+ 在 RC 隔离级别下的 `**每次select**` 查询前都生成一个`Read View` (m_ids 列表)
+ 在 RR 隔离级别下只在事务开始后 `**第一次select**` 数据前生成一个`Read View`（m_ids 列表）

# MySQL锁
## 全局锁
全局锁主要用于**全库逻辑备份**，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样

## 表级锁
### 表锁
表锁不仅会限制其他线程的操作，还会限制本线程的读写，在释放表锁之前也不能访问其他表

### 元数据锁
**元数据锁（Metadata Lock, MDL）** 是 MySQL 的一种锁机制，用于保护数据库对象（如表、视图、存储过程等）的元数据，确保在并发访问中元数据的一致性。我们不需要显示的使用MDL，因为我们对数据库表进行操作的时候会自动给这个表加上MDL。MDL 是从 MySQL 5.5 开始引入的，用来解决多个事务同时访问或修改表结构时的并发问题。

#### 元数据锁的作用
1. **保护元数据的完整性**：
    - 确保当事务正在使用某个表时，不能对该表的元数据（如表结构）进行修改。
2. **协调并发操作**：
    - 保证并发事务之间对表的访问或修改不会互相冲突。

#### 锁的类型
元数据锁主要有以下几种类型：

1. **MDL 读锁（SHARE, 共享锁）**：
    - 当事务只需要读取元数据时（如执行 `SELECT` 查询或事务需要用到表的结构信息），加读锁。
    - 读锁之间是共享的，多个事务可以同时获取同一个表的 MDL 读锁。
2. **MDL 写锁（EXCLUSIVE, 排他锁）**：
    - 当事务需要修改元数据时（如执行 `ALTER TABLE` 修改表结构或删除表），加写锁。
    - 写锁是排他的，一个事务获取写锁时，其他事务无法获取读锁或写锁。

#### 加锁场景
+ **读操作**（如 `SELECT`）：
    - 加 MDL 读锁，保护表的元数据不被更改。
+ **写操作**（如 `INSERT/UPDATE/DELETE`）：
    - 加 MDL 读锁，防止表结构发生变化。
+ **DDL 操作**（如 `ALTER TABLE` 或 `DROP TABLE`）：
    - 加 MDL 写锁，阻止并发事务访问或修改表。

### 意向锁
**目的是为了快速判断表里是否有记录被加锁**

意向锁是表级锁，共有两种：

+ **意向共享锁（Intention Shared Lock，IS 锁）****：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。**
+ **意向排他锁（Intention Exclusive Lock，IX 锁）****：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。**

**意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InnoDB 会先获取该数据行所在在数据表的对应意向锁。**

意向锁之间是互相兼容的。

|  | IS 锁 | IX 锁 |
| --- | --- | --- |
| IS 锁 | 兼容 | 兼容 |
| IX 锁 | 兼容 | 兼容 |


意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。

|  | IS 锁 | IX 锁 |
| --- | --- | --- |
| S 锁 | 兼容 | 互斥 |
| X 锁 | 互斥 | 互斥 |


### AUTO-INC锁
**自增锁（AUTO-INC Lock）** 是 MySQL 中为实现自增字段（`AUTO_INCREMENT`）功能而引入的一种特殊锁机制，旨在确保多个事务对自增字段的并发访问不会发生冲突。

## 行级锁
### Record Lock（记录锁）
锁住一条记录，并且记录锁有S锁和X锁之分（S读X锁）

### Gap Lock（间隙锁）
锁住记录之间的间隙

### Next-Key Lock（临建锁）
记录锁+间隙锁

### 插入意向锁
如果插入记录时候被间隙锁锁住，就会生成一个插入意向锁，代表事务在等待插入数据

# MySQL日志
## binlog（归档日志）
### binlog和redo log有什么区别
1. binlog是Server层实现的日志<font style="color:rgb(44, 62, 80);">，所有存储引擎都可以使用。redo log 是 Innodb 存储引擎实现的日志</font>
2. <font style="color:rgb(44, 62, 80);">binlog是逻辑日志，记录的是所有对数据库进行修改的语句，有三种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED。redo log是物理日志</font>
3. <font style="color:rgb(44, 62, 80);">binlog是追加写，保存全量的日志。redo log是循环写，保存未被刷入磁盘的脏页日志</font>
4. <font style="color:rgb(44, 62, 80);">binlog 用于备份恢复、主从复制。redo log 用于掉电等故障恢复。</font>

### <font style="color:rgb(44, 62, 80);">主从复制</font>
![](https://cdn.nlark.com/yuque/0/2025/png/39185937/1736141833193-6c6b0e30-2ef2-4e18-9556-5ae294233be5.png)

<font style="color:rgb(44, 62, 80);">MySQL 集群的主从复制过程梳理成 3 个阶段：</font>

+ **写入 Binlog**：主库写 binlog 日志，提交事务，并更新本地存储数据。
+ **同步 Binlog**：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中
+ **回放 Binlog**：回放 binlog，并更新存储引擎中的数据。

<font style="color:rgb(44, 62, 80);">具体详细过程如下：</font>

+ <font style="color:rgb(44, 62, 80);">MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</font>
+ <font style="color:rgb(44, 62, 80);">从库会创建一个专门的 I/O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。</font>
+ <font style="color:rgb(44, 62, 80);">从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</font>

### <font style="color:rgb(44, 62, 80);background-color:rgb(227, 242, 253);">MySQL 主从复制还有哪些模型？</font>
+ **同步复制**：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。
+ **异步复制**（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。
+ **半同步复制**：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。这种**半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险**。

### <font style="color:rgb(44, 62, 80);background-color:rgb(227, 242, 253);">什么时候 binlog cache 会写到 binlog 文件？</font>
![](https://cdn.nlark.com/yuque/0/2025/png/39185937/1736142281151-e0e65beb-282e-4b86-88fb-43b4c3a2b122.png)

<font style="color:rgb(44, 62, 80);">MySQL提供一个</font>**<font style="color:rgb(44, 62, 80);"> sync_binlog</font>**<font style="color:rgb(44, 62, 80);"> 参数来控制数据库的 binlog 刷到磁盘上的频率：</font>

+ <font style="color:rgb(44, 62, 80);">sync_binlog = 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；</font>
+ <font style="color:rgb(44, 62, 80);">sync_binlog = 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；</font>
+ <font style="color:rgb(44, 62, 80);">sync_binlog =N(N>1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</font>

### <font style="color:rgb(44, 62, 80);">两阶段提交</font>
![](https://cdn.nlark.com/yuque/0/2025/png/39185937/1736142853121-728e97e6-0f32-4a41-8fde-bfe817f37475.png)

## redo log（重做日志）
### <font style="color:rgb(44, 62, 80);background-color:rgb(227, 242, 253);">redo log 和 undo log 区别在哪？</font>
+ redo log 记录了此次事务「**修改后**」的数据状态，记录的是更新**之后**的值，**主要用于事务崩溃恢复，保证事务的持久性**。
+ undo log 记录了此次事务「**修改前**」的数据状态，记录的是更新**之前**的值，**主要用于事务回滚，保证事务的原子性**。

![](https://cdn.nlark.com/yuque/0/2025/png/39185937/1736140665047-9b1bc618-9d1e-456f-a521-72909f249f44.png)

### <font style="color:rgb(44, 62, 80);">redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？</font>
写入 redo log 的方式使用了追加操作， 所以磁盘操作是**顺序写**，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是**随机写**。

### 刷盘时机
InnoDB 将 redo log 刷到磁盘上有几种情况：

1. 事务提交：当事务提交时，log buffer 里的 redo log 会被刷新到磁盘（可以通过`innodb_flush_log_at_trx_commit`参数控制，后文会提到）。
2. log buffer 空间不足时：log buffer 中缓存的 redo log 已经占满了 log buffer 总容量的大约一半左右，就需要把这些日志刷新到磁盘上。
3. 事务日志缓冲区满：InnoDB 使用一个事务日志缓冲区（transaction log buffer）来暂时存储事务的重做日志条目。当缓冲区满时，会触发日志的刷新，将日志写入磁盘。
4. Checkpoint（检查点）：InnoDB 定期会执行检查点操作，将内存中的脏数据（已修改但尚未写入磁盘的数据）刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。
5. 后台刷新线程：InnoDB 启动了一个后台线程，负责周期性（每隔 1 秒）地将脏页（已修改但尚未写入磁盘的数据页）刷新到磁盘，并将相关的重做日志一同刷新。
6. 正常关闭服务器：MySQL 关闭的时候，redo log 都会刷入到磁盘里去。

`innodb_flush_log_at_trx_commit` 的值有 3 种，也就是共有 3 种刷盘策略：

+ **0**：设置为 0 的时候，表示每次事务提交时不进行刷盘操作。这种方式性能最高，但是也最不安全，因为如果 MySQL 挂了或宕机了，可能会丢失最近 1 秒内的事务。
+ **1**：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作。这种方式性能最低，但是也最安全，因为只要事务提交成功，redo log 记录就一定在磁盘里，不会有任何数据丢失。
+ **2**：设置为 2 的时候，表示每次事务提交时都只把 log buffer 里的 redo log 内容写入 page cache（文件系统缓存）。page cache 是专门用来缓存文件的，这里被缓存的文件就是 redo log 文件。这种方式的性能和安全性都介于前两者中间。

## Undo log（回滚日志）
1. 每一个事务对数据的修改都会被记录到 undo log ，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL 可以利用 undo log 将数据恢复到事务开始之前的状态。
2. undo log 属于逻辑日志，记录的是 SQL 语句，比如说事务执行一条 DELETE 语句，那 undo log 就会记录一条相对应的 INSERT 语句。同时，undo log 的信息也会被记录到 redo log 中，因为 undo log 也要实现持久性保护。并且，undo-log 本身是会被删除清理的，例如 INSERT 操作，在事务提交之后就可以清除掉了；UPDATE/DELETE 操作在事务提交不会立即删除<font style="color:rgb(60, 60, 67);">，会加入 history list，由后台线程 purge 进行清理；回滚时候对insert语句是直接插入，而</font><font style="color:rgb(44, 62, 80);">针对 delete 操作和 update 操作会有一些特殊的处理：</font>
+ delete对象会被打上delete flag，由后台线程 purge 进行清理。
+ update的列不是主键列的话会直接反向记录update，否则先删除该行再插入目标行
3. undo log 是采用 segment（段）的方式来记录的，每个 undo 操作在记录的时候占用一个 **undo log segment**（undo 日志段），undo log segment 包含在 **rollback segment**（回滚段）中。事务开始时，需要为其分配一个 rollback segment。每个 rollback segment 有 1024 个 undo log segment，这有助于管理多个并发事务的回滚需求。
4. 通常情况下， **rollback segment header**（通常在回滚段的第一个页）负责管理 rollback segment。rollback segment header 是 rollback segment 的一部分，通常在回滚段的第一个页。**history list** 是 rollback segment header 的一部分，它的主要作用是记录所有已经提交但还没有被清理（purge）的事务的 undo log。这个列表使得 purge 线程能够找到并清理那些不再需要的 undo log 记录。
5. 另外，`MVCC` 的实现依赖于：**隐藏字段、Read View、undo log**。在内部实现中，InnoDB 通过数据行的 `DB_TRX_ID` 和 `Read View` 来判断数据的可见性，如不可见，则通过数据行的 `DB_ROLL_PTR` 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 `Read View` 之前已经提交的修改和该事务本身做的修改

## Buffer Pool
InnoDb会为Buffer Pool申请一片连续的内存空间，然后按照默认的16KB大小划分出一个个的页，Buffer Pool中的页就叫做缓存页（默认大小128MB）

![](https://cdn.nlark.com/yuque/0/2025/png/39185937/1736140243665-130dda91-6027-47eb-9355-302f4db6d758.png)

Undo页是用来记录undo log的

查询一条记录时会将该记录的整个页的数据加载到Buffer Pool当中

**WAL（Weite-Ahead Logging）技术：**MySQL的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时机写在磁盘上。

![](https://cdn.nlark.com/yuque/0/2025/png/39185937/1736140474693-1e107d37-fb09-484a-b064-2903603862b2.png)

### <font style="color:rgb(44, 62, 80);">如何管理空闲页？</font>
**Free链表（空闲链表）：**

![](https://cdn.nlark.com/yuque/0/2025/png/39185937/1736143179068-df79f14b-5e67-4f2f-819d-d386994372f5.png)

### <font style="color:rgb(44, 62, 80);">如何管理脏页？</font>
Flush链表（刷新链表）：

![](https://cdn.nlark.com/yuque/0/2025/png/39185937/1736143269164-3b60791a-c0ea-4e5c-ae5d-4154e902b2ad.png)

### 怎样避免预读失效？
MySQL 是这样做的，它改进了 LRU 算法，将 LRU 划分了 2 个区域：**old 区域 和 young 区域**。

young 区域在 LRU 链表的前半部分，old 区域则是在后半部分，如下图：

![](https://cdn.nlark.com/yuque/0/2025/png/39185937/1736143588583-f64887ff-ab5a-4c25-a6be-68f452246115.png)

old 区域占整个 LRU 链表长度的比例可以通过 `innodb_old_blocks_pct` 参数来设置，默认是 37，代表整个 LRU 链表中young 区域与 old 区域比例是 63:37。

**划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部**。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。

### Buffer Pool污染
当某一个 SQL 语句**扫描了大量的数据**时，在 Buffer Pool 空间比较有限的情况下，可能会将 **Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了，**等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 **Buffer Pool 污染**。

**怎么解决？**

MySQL 是这样做的，进入到 young 区域条件增加了一个**停留在 old 区域的时间判断**。如果后续的访问时间与第一次访问的时间**在某个时间间隔内**，那么**该缓存页就不会被从 old 区域移动到 young 区域的头部**；<font style="color:rgb(44, 62, 80);">另外，MySQL 针对 young 区域其实做了一个优化，为了防止 young 区域节点频繁移动到头部。young 区域前面 1/4 被访问不会移动到链表头部，只有后面的 3/4被访问了才会。</font>

### <font style="color:rgb(44, 62, 80);">脏页什么时候会被刷入磁盘</font>
+ <font style="color:rgb(44, 62, 80);">当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；</font>
+ <font style="color:rgb(44, 62, 80);">Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；</font>
+ <font style="color:rgb(44, 62, 80);">MySQL 认为空闲时，后台线程会定期将适量的脏页刷入到磁盘；</font>
+ <font style="color:rgb(44, 62, 80);">MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；</font>

