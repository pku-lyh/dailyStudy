## TCP/IP模型
**应用层**：与用户进行交互，向下传输数据

HTTP（超文本传输协议）、DNS（域名管理系统）、FTP（文件传输协议）、SMTP（简单邮件传输协议）、POP3（邮件接受协议）、TELNET（没有了解）

**传输层**：提供端到端之间的传输，给数据加上TCP头部封装成段

TCP、UDP

**网络层**：负责路由与寻址，给数据加上IP头部封装成IP数据包，如果数据包大小超过MTU（最大传输单元）需要进行分片

IP（IP协议）、ARP（地址解析协议）、OSPF（开放最短路径优先）、BGP（边界网关协议）

**网络接口层：**给数据加上帧头和帧尾封装成帧，以MAC地址进行寻址



## 键入网址到页面展示发生了什么
1. 对URL进行解析，确认Web服务器和文件名，生成HTTP请求报文
2. HTTP是运行在TCP上的服务，但是建立TCP连接之前需要获取目标域名的IP地址，此时就需要DNS域名管理系统查询域名对应的IP地址（HTTP应用层）
3. 拿到对应IP地址之后，会向对方请求建立一条TCP连接，期间涉及三次握手和四次握手，并且给数据加上一个TCP头部将数据封装成段（TCP传输层）
4. 数据传输之前需要通过IP协议给数据再加上IP头部将数据封装成为IP数据报（IP网络层），然后根据ARP地址解析协议获取对应地址的MAC地址，给数据加上MAC头部（数据链路层）
5. 最后网卡接收到这个网络包之后将数据复制到缓冲区，在开头加上报头和起始帧分界符，末尾加上FCS（帧校验序列），然后将数据转换成电信号发送出去
6. 交换机接收到电信号之后转换为数字信号，检测FCS无差错的话放到缓冲区，然后查询MAC地址表将数据转发到对应的端口，地址表当中没有的话就广播
7. 路由器同样将电信号转换为数字信号，检测FCS无差错并且目标MAC地址是自己的话就接受，然后查路由表进行转发
8. 服务器接收到数据之后一层层进行拆解，MAC头部、IP头部、TCP头部，最后将数据发送给服务器的HTTP进程，HTTP进程处理后再将数据封装到HTTP响应报文中，然后通过同样的步骤返回回来



## HTTP协议
HTTP是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频、等超文本数据的约定和规范

### HTTP常见状态码
![](https://cdn.nlark.com/yuque/0/2024/png/39185937/1735467641997-6111a87c-3097-4c1d-8ab7-0080d83301f3.png)

### HTTP常见字段
+ **Host字段：**用来指定服务器的域名
+ **Content-Length字段：**服务器返回数据时候的回应长度，HTTP通过设置回车符、换行符作为HTTP header的边界，通过Content-Length字段作为body 的边界来解决粘包问题
+ **Connection字段：**用于客户端要求服务器使用长连接，即设置为Keep-Alive
+ **Content-Type字段：**服务器回应客户端本次数据是什么格式
+ **Content-Encoding字段：**说明数据的压缩方法

### 队头阻塞问题
顺序发送的请求序列中的一个请求因为某种原因被阻塞时，后面排队的所有请求也一起被阻塞

### HTTPS和HTTP的区别
+ 安全的超文本传输协议，基于SSL/TLS安全协议，使得报文能够加密传输
+ HTTPS三次握手后还需要进行SSL/TLS的握手过程才可以进入加密报文传输
+ HTTPS需要向CA（证书权威机构）神奇数字证书来保证服务器的身份可信

### HTTPS怎么保证安全？
**混合加密：**

1. 客户端向服务端发起加密通信请求，也就是发起握手
2. 服务端发送给客户端一个非对称加密的公匙证书
3. 客户端验证服务端的证书
4. 验证通过后客户端生成一个对称加密的会话密钥
5. 用公匙对会话密钥进行加密并将加密后的密钥发送到服务端
6. 服务端用私匙进行解密拿到会话密钥，告知客户端握手阶段结束

**摘要算法+数字签名：**

1. 通过摘要算法计算内容的哈希值，也就是内容的指纹，对方收到后也需要计算出指纹然后进行对比以确认内容是否被修改（但是内容和哈希值可能一起被修改）
2. 通过私钥对指纹进行加密以保证不会被篡改，因为如果被修改，客户端通过公钥是无法进行解密的（但是公钥也能被伪造）

**数字证书：**

1. 服务器需要将自己的公钥注册到CA（数字证书认证机构）
2. CA用自己的私钥将服务器的公钥数字签名并颁发数字证书
3. 客户端拿到服务器的数字证书后使用CA的公钥确认证书的真实性
4. 再用服务器的公钥对数据进行加密



### HTTP/1.1相比HTTP/1.0的优点
+ 长连接
+ 支持管道网络传输，只要第一个请求发出去了， 不需要等请求返回就可以继续发送第二个请求
+ <font style="color:rgb(60, 60, 67);">在请求头引入了 range 头域，它允许只请求资源的某个部分，充分利用带宽</font>
+ <font style="color:rgb(60, 60, 67);">HTTP/1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能</font>

### HTTP/2.0相比HTTP/1.1的优点
+ **多路复用（Multiplexing）**：HTTP/2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP/1.1 中长链接的升级版本），互不干扰。HTTP/1.1 则使用串行方式，每个请求和响应都需要独立的连接，而浏览器为了控制资源会有 6-8 个 TCP 连接的限制。。这使得 HTTP/2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。
+ **二进制帧（Binary Frames）**：HTTP/2.0 使用二进制帧进行数据传输，而 HTTP/1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。
+ **头部压缩（Header Compression）**：HTTP/1.1 支持`Body`压缩，`Header`不支持压缩。HTTP/2.0 支持对`Header`压缩，使用了专门为`Header`压缩而设计的 HPACK 算法，减少了网络开销。
+ **服务器推送（Server Push）**：HTTP/2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP/1.1 需要客户端自己发送请求来获取相关资源。

### HTTP/3.0相做了哪些优化
核心是改用基于UDP的QUIC协议

+ **无队头阻塞：**一<font style="color:rgb(60, 60, 67);">个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其他数据流不受影响（本质上是多路复用+轮询）。</font>
+ **更快的连接建立：**基于TLS1.3，连接建立仅需要<font style="color:rgb(60, 60, 67);">0-RTT 或者 1-RTT</font>
+ **连接迁移：** QUIC 使用 64 位 ID 标识连接，只要 ID 不变就不会中断，网络环境改变时（如从 Wi-Fi 切换到移动数据）也能保持连接。而 TCP 连接是由（源 IP，源端口，目的 IP，目的端口）组成，这个四元组中一旦有一项值发生改变，这个连接也就不能用了。
+ **更好的错误回复机制：** QUIC 可以对每个流单独进行流量控制和丢包恢复，使得在丢包发生时，影响最小化。 ** **

### 既然有HTTP协议为什么还要有RPC
+ 先出现的RPC再出现的HTTP
+ RPC（远程过程调用）不是协议，只是调用方式，比如gRPC才是协议
+ RPC适用于自己公司的客户端调用自家服务器的方法，但是在网络上大部分都是需要访问其他公司的网站服务器，这时候RPC就不太适用了，大家需要统一访问的标准才能访问，因此出现了HTTP
+ 主流的HTTP/1.1的头部在某些情况下比较冗余，且使用Json格式来序列化结构体数据，而RPC可以采用体积更小的ProtoBuf或者其他序列化协议来保存对象，也不用考虑复杂的网络行为，比如网络重定向，所以性能比HTTP/1.1要好一些
+ 但是HTTP/2.0的性能要更好，不过出来的比较晚，许多公司的RPC服务已经跑了好几年了所以也没必要换

### 既然有HTTP协议为什么还要有WebSocket
+ WebSocket 是一种双向实时通信协议，而 HTTP 是一种单向通信协议。并且，HTTP 协议下的通信只能由客户端发起，服务器无法主动通知客户端。
+ WebSocket 使用 ws:// 或 wss://（使用 SSL/TLS 加密后的协议，类似于 HTTP 和 HTTPS 的关系） 作为协议前缀，HTTP 使用 http:// 或 https:// 作为协议前缀。
+ WebSocket 可以支持扩展，用户可以扩展协议，实现部分自定义的子协议，如支持压缩、加密等。
+ WebSocket 通信数据格式比较轻量，用于协议控制的数据包头部相对较小，网络开销小，而 HTTP 通信每次都要携带完整的头部，网络开销较大（HTTP/2.0 使用二进制帧进行数据传输，还支持头部压缩，减少了网络开销）。

WebSocket 的工作过程可以分为以下几个步骤：

1. 客户端向服务器发送一个 HTTP 请求，请求头中包含 `Upgrade: websocket` 和 `Sec-WebSocket-Key` 等字段，表示要求升级协议为 WebSocket，同时带上随机生成的base64码；
2. 服务器收到这个请求后，会进行升级协议的操作，如果支持 WebSocket，它将回复一个 HTTP 101 状态码（代表协议转换），响应头中包含 ，`Connection: Upgrade`和 `Sec-WebSocket-Accept: xxx` 等字段，其中Sec-WebSocket-Accept存储的是用一个公开算法将base64码转化成的另一段字符串，表示成功升级到 WebSocket 协议。
3. 客户端和服务器之间建立了一个 WebSocket 连接，可以进行双向的数据传输。数据以帧（frames）的形式进行传送，WebSocket 的每条消息可能会被切分成多个数据帧（最小单位）。发送端会将消息切割成多个帧发送给接收端，接收端接收消息帧，并将关联的帧重新组装成完整的消息。
4. 客户端或服务器可以主动发送一个关闭帧，表示要断开连接。另一方收到后，也会回复一个关闭帧，然后双方关闭 TCP 连接。

<<<<<<< HEAD


## TCP协议
**面向连接的、可靠的、基于字节流的传输层通信协议**

### TCP头部重要字段
**序列号（Seq）：**用来解决网络包乱序问题

**确认号（ACK）：**用来解决丢包问题

**控制位：**

+ ACK为1：确认应答的字段变为有效
+ RST为1：出现异常必须强制断开连接
+ SYN为1：希望建立连接
+ FIN为1：希望断开连接

### TCP四元组唯一标识一个TCP连接


### TCP和UDP的区别
1. **是否面向连接**：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。
2. **是否是可靠传输**：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。
3. **是否有状态**：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（**这很渣男！**）。
4. **传输效率**：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。
5. **传输形式**：TCP 是面向字节流的，UDP 是面向报文的。
6. **首部开销**：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。
7. **是否提供广播或多播服务**：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；

| | TCP | UDP |
| --- | --- | --- |
| 是否面向连接 | 是 | 否 |
| 是否可靠 | 是 | 否 |
| 是否有状态 | 是 | 否 |
| 传输效率 | 较慢 | 较快 |
| 传输形式 | 字节流 | 数据报文段 |
| 首部开销 | 20 ～ 60 bytes | 8 bytes |
| 是否提供广播或多播服务 | 否 | 是 |


### TCP三次握手和四次挥手
**三次握手：**

![](https://cdn.nlark.com/yuque/0/2024/png/39185937/1735540519952-a9d21b83-eaff-4a63-9572-bbf9ecafc6dc.png)

+ **一次握手**:客户端发送带有 SYN（SEQ=x） 标志的数据包 -> 服务端，然后客户端进入 **SYN_SEND** 状态，等待服务端的确认；
+ **二次握手**:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –> 客户端,然后服务端进入 **SYN_RECV** 状态；
+ **三次握手**:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –> 服务端，然后客户端和服务端都进入**ESTABLISHED** 状态，完成 TCP 三次握手。

**原因：**

+ 保证双方都有接受和发送数据的能力
+ 阻止重复历史连接的初始化（主要原因）
+ 同步双方的初始序列号
+ 避免资源浪费

还有很多其他的很详细的原因，参考小林coding[https://xiaolincoding.com/network/3_tcp/tcp_interview.html#](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%8F%E6%AC%A1%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5%E6%97%B6-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%BA%8F%E5%88%97%E5%8F%B7%E9%83%BD%E8%A6%81%E6%B1%82%E4%B8%8D%E4%B8%80%E6%A0%B7%E5%91%A2)



**四次挥手：**

![](https://cdn.nlark.com/yuque/0/2024/png/39185937/1735542680478-c753a8a6-0587-4117-92b7-9e2fd8c82063.png)

断开一个 TCP 连接则需要“四次挥手”，缺一不可：

1. 第一次挥手：客户端发送一个 FIN（SEQ=x） 标志的数据包->服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 FIN-WAIT-1 状态。
2. 第二次挥手：服务端收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包->客户端 。然后服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。
3. 第三次挥手：服务端发送一个 FIN (SEQ=y)标志的数据包->客户端，请求关闭连接，然后服务端进入 LAST-ACK 状态。
4. 第四次挥手：客户端发送 ACK (ACK=y+1)标志的数据包->服务端，然后客户端进入TIME-WAIT状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。

只要四次挥手没有结束，客户端和服务端就可以继续传输数据！

### 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？
+ 第四次挥手时，客户端发送给服务端的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。
+ 确保网络中的所有所有数据包都已经消失，避免影响下一次连接

### <font style="color:rgb(44, 62, 80);">服务器出现大量 TIME_WAIT 状态的原因有哪些？</font>
+ 第一个场景：HTTP 没有使用长连接
+ 第二个场景：HTTP 长连接超时
+ 第三个场景：HTTP 长连接的请求数量达到上限

### 如果已经建立了连接，但是客户端突然出现故障了怎么办？
TCP有一个保活机制：如果一个时间段内没有任何连接相关的活动，那么就会不间断的发送探测报文，连续几个报文都没有得到响应之后就会认为当前TCP连接已经死亡

### <font style="color:rgb(44, 62, 80);">如果已经建立了连接，但是服务端的进程崩溃会发生什么？</font>
内核会回收该进程的所有TCP连接资源，代替服务端进程与客户端完成四次挥手的过程

### <font style="color:rgb(60, 60, 67);">TCP 如何保证传输的可靠性？</font>
+ 基于数据块传输
+ 基于序列号对失序数据包重新排序以及去重
+ 保持首部和数据的检验和
+ 基于确认号来实现重传机制
+ 基于滑动窗口实现流量控制
+ 维护一个拥塞窗口来实现拥塞控制

### 小林coding上还有很多详细的问题介绍和解决方案，但是我觉得太细了就不总结了
[https://xiaolincoding.com/network/3_tcp](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86)

## IP协议
### DNS域名管理系统
浏览器缓存->操作系统缓存->本机域名解析文件hosts->DNS域名解析

迭代和递归

![](https://cdn.nlark.com/yuque/0/2024/png/39185937/1735554789816-27c8f9ab-b186-44be-ae9e-df0c7a95f9c7.png)

现在，主机`cis.poly.edu`想知道`gaia.cs.umass.edu`的 IP 地址。假设主机`cis.poly.edu`的本地 DNS 服务器为`dns.poly.edu`，并且`gaia.cs.umass.edu`的权威 DNS 服务器为`dns.cs.umass.edu`。

1. 首先，主机`cis.poly.edu`向本地 DNS 服务器`dns.poly.edu`发送一个 DNS 请求，该查询报文包含被转换的域名`gaia.cs.umass.edu`。
2. 本地 DNS 服务器`dns.poly.edu`检查本机缓存，发现并无记录，也不知道`gaia.cs.umass.edu`的 IP 地址该在何处，不得不向根服务器发送请求。
3. 根服务器注意到请求报文中含有`edu`顶级域，因此告诉本地 DNS，你可以向`edu`的 TLD DNS 发送请求，因为目标域名的 IP 地址很可能在那里。
4. 本地 DNS 获取到了`edu`的 TLD DNS 服务器地址，向其发送请求，询问`gaia.cs.umass.edu`的 IP 地址。
5. `edu`的 TLD DNS 服务器仍不清楚请求域名的 IP 地址，但是它注意到该域名有`umass.edu`前缀，因此返回告知本地 DNS，`umass.edu`的权威服务器可能记录了目标域名的 IP 地址。
6. 这一次，本地 DNS 将请求发送给权威 DNS 服务器`dns.cs.umass.edu`。
7. 终于，由于`gaia.cs.umass.edu`向权威 DNS 服务器备案过，在这里有它的 IP 地址记录，权威 DNS 成功地将 IP 地址返回给本地 DNS。
8. 最后，本地 DNS 获取到了目标域名的 IP 地址，将其返回给请求主机。

![](https://cdn.nlark.com/yuque/0/2024/png/39185937/1735554795960-dc0bbe0b-973c-4bea-989d-018897d88661.png)

与迭代类似



### ARP地址解析协议
ARP 解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。

#### [<font style="color:rgb(60, 60, 67);">同一局域网内的 MAC 寻址</font>](https://javaguide.cn/cs-basics/network/arp.html#%E5%90%8C%E4%B8%80%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E7%9A%84-mac-%E5%AF%BB%E5%9D%80)
假设当前有如下场景：IP 地址为`137.196.7.23`的主机 A，想要给同一局域网内的 IP 地址为`137.196.7.14`主机 B，发送 IP 数据报文。

再次强调，当主机发送 IP 数据报文时（网络层），仅知道目的地的 IP 地址，并不清楚目的地的 MAC 地址，而 ARP 协议就是解决这一问题的。

为了达成这一目标，主机 A 将不得不通过 ARP 协议来获取主机 B 的 MAC 地址，并将 IP 报文封装成链路层帧，发送到下一跳上。在该局域网内，关于此将按照时间顺序，依次发生如下事件：

1. 主机 A 检索自己的 ARP 表，发现 ARP 表中并无主机 B 的 IP 地址对应的映射条目，也就无从知道主机 B 的 MAC 地址。
2. 主机 A 将构造一个 ARP 查询分组，并将其广播到所在的局域网中。
3. ARP 分组是一种特殊报文，ARP 分组有两类，一种是**查询分组**，另一种是**响应分组**，它们具有相同的格式，均包含了发送和接收的 IP 地址、发送和接收的 MAC 地址。当然了，查询分组中，发送的 IP 地址，即为主机 A 的 IP 地址，接收的 IP 地址即为主机 B 的 IP 地址，发送的 MAC 地址也是主机 A 的 MAC 地址，但接收的 MAC 地址绝不会是主机 B 的 MAC 地址（因为这正是我们要问询的！），而是一个特殊值——`FF-FF-FF-FF-FF-FF`，之前说过，该 MAC 地址是广播地址，也就是说，查询分组将**广播**给该局域网内的所有设备。
4. 主机 A 构造的查询分组将在该局域网内广播，理论上，每一个设备都会收到该分组，并检查查询分组的接收 IP 地址是否为自己的 IP 地址，如果是，说明查询分组已经到达了主机 B，否则，该查询分组对当前设备无效，丢弃之。
5. 主机 B 收到了查询分组之后，验证是对自己的问询，接着构造一个 ARP 响应分组，该分组的目的地只有一个——主机 A，发送给主机 A。同时，主机 B 提取查询分组中的 IP 地址和 MAC 地址信息，在自己的 ARP 表中构造一条主机 A 的 IP-MAC 映射记录。
6. ARP 响应分组具有和 ARP 查询分组相同的构造，不同的是，发送和接受的 IP 地址恰恰相反，发送的 MAC 地址为发送者本身，目标 MAC 地址为查询分组的发送者，也就是说，ARP 响应分组只有一个目的地，而非广播。
7. 主机 A 终将收到主机 B 的响应分组，提取出该分组中的 IP 地址和 MAC 地址后，构造映射信息，加入到自己的 ARP 表中。

#### 不同局域网内的 MAC 寻址
更复杂的情况是，发送主机 A 和接收主机 B 不在同一个子网中，假设一个一般场景，两台主机所在的子网由一台路由器联通。这里需要注意的是，一般情况下，我们说网络设备都有一个 IP 地址和一个 MAC 地址，这里说的网络设备，更严谨的说法应该是一个接口。路由器作为互联设备，具有多个接口，每个接口同样也应该具备不重复的 IP 地址和 MAC 地址。因此，在讨论 ARP 表时，路由器的多个接口都各自维护一个 ARP 表，而非一个路由器只维护一个 ARP 表。

接下来，回顾同一子网内的 MAC 寻址，如果主机 A 发送一个广播问询分组，那么 A 所在的子网内所有设备（接口）都将会捕获该分组，因为该分组的目的 IP 与发送主机 A 的 IP 在同一个子网中。但是当目的 IP 与 A 不在同一子网时，A 所在子网内将不会有设备成功接收该分组。那么，主机 A 应该发送怎样的查询分组呢？整个过程按照时间顺序发生的事件如下：

1. 主机 A 查询 ARP 表，期望寻找到目标路由器的本子网接口的 MAC 地址。目标路由器指的是，根据目的主机 B 的 IP 地址，分析出 B 所在的子网，能够把报文转发到 B 所在子网的那个路由器。
2. 主机 A 未能找到目标路由器的本子网接口的 MAC 地址，将采用 ARP 协议，问询到该 MAC 地址，由于目标接口与主机 A 在同一个子网内，该过程与同一局域网内的 MAC 寻址相同。
3. 主机 A 获取到目标接口的 MAC 地址，先构造 IP 数据报，其中源 IP 是 A 的 IP 地址，目的 IP 地址是 B 的 IP 地址，再构造链路层帧，其中源 MAC 地址是 A 的 MAC 地址，目的 MAC 地址是**本子网内与路由器连接的接口的 MAC 地址**。主机 A 将把这个链路层帧，以单播的方式，发送给目标接口。
4. 目标接口接收到了主机 A 发过来的链路层帧，解析，根据目的 IP 地址，查询转发表，将该 IP 数据报转发到与主机 B 所在子网相连的接口上。到此，该帧已经从主机 A 所在的子网，转移到了主机 B 所在的子网了。
5. 路由器接口查询 ARP 表，期望寻找到主机 B 的 MAC 地址。
6. 路由器接口如未能找到主机 B 的 MAC 地址，将采用 ARP 协议，广播问询，单播响应，获取到主机 B 的 MAC 地址。
7. 路由器接口将对 IP 数据报重新封装成链路层帧，目标 MAC 地址为主机 B 的 MAC 地址，单播发送，直到目的地。

**补充一下：**

#### IP 层如何决定应该将数据包转发到哪个路由器？
主机 A 在发送数据包时，会先根据目标 IP 地址（即主机 B 的 IP 地址）和自身的子网掩码，判断目标主机 B 是否在同一个子网内：

+ 如果 **主机 B 的 IP 地址与主机 A 在同一个子网内**，主机 A 可以直接通过 ARP 查询获取主机 B 的 MAC 地址，将数据包发送到主机 B。
+ 如果 **主机 B 的 IP 地址与主机 A 不在同一个子网内**，主机 A 知道需要将数据包发给默认网关（即目标路由器），而不是直接发送给主机 B。这时，主机 A 会查找自己的 **默认网关（默认路由器）的 IP 地址**。



### DHCP
#### DHCP 动态获取 IP 地址的过程  
当一个设备（客户端）首次连接到网络并需要动态获取 IP 地址时，DHCP 过程大致分为以下几个阶段：
1. **DHCP Discover（发现）**  
客户端启动时，首先会发送一个 DHCP Discover 广播包到网络中，目的是寻找网络中的 DHCP 服务器。  
该包的目的地址是 255.255.255.255，并且源 IP 地址为 0.0.0.0，因为此时客户端并未获得 IP 地址。
2. **DHCP Offer（提供）**  
网络中的 DHCP 服务器收到 Discover 消息后，会检查其 IP 地址池是否有可用的 IP 地址。  
如果有，DHCP 服务器会选择一个可用的 IP 地址，并向客户端发送一个 DHCP Offer 消息，内容包括：  
提供的 IP 地址、子网掩码、默认网关、DNS 服务器等配置信息  
该消息是单播或广播发送的，包含的目标地址是客户端的 MAC 地址。
3. **DHCP Request（请求）**  
客户端收到 DHCP Offer 后，会选择一个服务器的 Offer 并发送一个 DHCP Request 消息。该消息向网络中的所有 DHCP 服务器广播，告知自己选择了某个特定的 IP 地址。  
DHCP Request 消息中也会包含客户端的 MAC 地址和请求的 IP 地址。
4. **DHCP Acknowledgment（确认）**  
DHCP 服务器收到客户端的 DHCP Request 消息后，确认并将 IP 地址分配给客户端。然后，服务器会发送一个 DHCP Acknowledgment（DHCP ACK）消息，告诉客户端已经成功分配了 IP 地址。  
客户端接收到 DHCP ACK 后，便可以使用该 IP 地址进行网络通信。

客户端在到期之前可以向服务端发送DHCP请求报文续租

### NAT
**NAT**（Network Address Translation，网络地址转换）是一种在网络中进行地址转换的技术，主要用于在私有网络与公共网络（如互联网）之间进行通信时，改变 IP 地址。NAT 通过将私有 IP 地址转换为公有 IP 地址（或反向转换）来实现网络中设备之间的通信。  

**NAT**可以通过端口地址转换使多个私有 IP 地址共享同一个公有 IP 地址，通过 **源端口号** 来区分每个连接。  

### ICMP
 ICMP 是一种 **控制和错误报告协议**，它用于在计算机网络中发送控制消息，帮助管理和诊断网络通信。ICMP 并不直接传输数据，它通常伴随着 IP 数据包使用，提供有关 IP 数据包的错误信息或网络状态的信息。  

#### **ICMP 的常见应用**
1. **错误报告**
    - **目标不可达（Destination Unreachable）**：如果数据包无法到达目的地，路由器会发送该消息给源主机，通知目标不可达。
    - **时间超过（Time Exceeded）**：当数据包的生存时间（TTL）到期时，路由器会返回此消息给源主机，告知其数据包被丢弃。
    - **参数问题（Parameter Problem）**：如果 IP 数据包的某个字段无效或无法解析，路由器会发送此消息。
2. **诊断工具**
    - **ping**：`ping` 命令利用 ICMP 的 **Echo Request** 和 **Echo Reply** 消息来测试网络的连通性。客户端发送一个 Echo Request 消息，目标主机收到后返回 Echo Reply 消息。通过往返时间可以评估网络的延迟和连通性。
    - **traceroute**：`traceroute` 使用 ICMP 的 **Time Exceeded** 消息来追踪数据包在网络中经过的路由路径。它通过设置不同的 TTL 值来获取经过的路由器的信息。
3. **流量控制**
    - **源抑制（Source Quench）**：这是一种指示发送方减少发送速率的消息，通常由路由器发送，表示网络过载或拥堵。

### IGMP
 IGMP 是一种用于 **管理主机在 IP 网络中的组成员身份** 的协议。它主要用于 **多播（multicast）** 通信中，让主机能够加入或离开特定的多播组。IGMP 在局域网中工作，用于 IP 网络中的多播通信管理。  

#### **IGMP 的工作原理**
+ IGMP 允许主机向路由器报告它们对特定多播组的兴趣。通过 IGMP，主机可以通知局域网中的路由器它是否希望接收来自某个多播地址的数据。
+ 当一个主机希望接收某个多播组的数据时，它会发送 IGMP 加入报告（Join Report）消息到组播路由器；如果不再需要接收数据，则发送 IGMP 离开报告（Leave Report）消息。

