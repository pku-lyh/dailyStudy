## TCP/IP模型
**应用层**：与用户进行交互，向下传输数据

HTTP（超文本传输协议）、DNS（域名管理系统）、FTP（文件传输协议）、SMTP（简单邮件传输协议）、POP3（邮件接受协议）、TELNET（没有了解）

**传输层**：提供端到端之间的传输，给数据加上TCP头部封装成段

TCP、UDP

**网络层**：负责路由与寻址，给数据加上IP头部封装成IP数据包，如果数据包大小超过MTU（最大传输单元）需要进行分片

IP（IP协议）、ARP（地址解析协议）、OSPF（开放最短路径优先）、BGP（边界网关协议）

**网络接口层：**给数据加上帧头和帧尾封装成帧，以MAC地址进行寻址



## 键入网址到页面展示发生了什么
1. 对URL进行解析，确认Web服务器和文件名，生成HTTP请求报文
2. HTTP是运行在TCP上的服务，但是建立TCP连接之前需要获取目标域名的IP地址，此时就需要DNS域名管理系统查询域名对应的IP地址（HTTP应用层）
3. 拿到对应IP地址之后，会向对方请求建立一条TCP连接，期间涉及三次握手和四次握手，并且给数据加上一个TCP头部将数据封装成段（TCP传输层）
4. 数据传输之前需要通过IP协议给数据再加上IP头部将数据封装成为IP数据报（IP网络层），然后根据ARP地址解析协议获取对应地址的MAC地址，给数据加上MAC头部（数据链路层）
5. 最后网卡接收到这个网络包之后将数据复制到缓冲区，在开头加上报头和起始帧分界符，末尾加上FCS（帧校验序列），然后将数据转换成电信号发送出去
6. 交换机接收到电信号之后转换为数字信号，检测FCS无差错的话放到缓冲区，然后查询MAC地址表将数据转发到对应的端口，地址表当中没有的话就广播
7. 路由器同样将电信号转换为数字信号，检测FCS无差错并且目标MAC地址是自己的话就接受，然后查路由表进行转发
8. 服务器接收到数据之后一层层进行拆解，MAC头部、IP头部、TCP头部，最后将数据发送给服务器的HTTP进程，HTTP进程处理后再将数据封装到HTTP响应报文中，然后通过同样的步骤返回回来



## HTTP协议
HTTP是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频、等超文本数据的约定和规范

### HTTP常见状态码
![](https://cdn.nlark.com/yuque/0/2024/png/39185937/1735467641997-6111a87c-3097-4c1d-8ab7-0080d83301f3.png)

### HTTP常见字段
+ **Host字段：**用来指定服务器的域名
+ **Content-Length字段：**服务器返回数据时候的回应长度，HTTP通过设置回车符、换行符作为HTTP header的边界，通过Content-Length字段作为body 的边界来解决粘包问题
+ **Connection字段：**用于客户端要求服务器使用长连接，即设置为Keep-Alive
+ **Content-Type字段：**服务器回应客户端本次数据是什么格式
+ **Content-Encoding字段：**说明数据的压缩方法

### 队头阻塞问题
顺序发送的请求序列中的一个请求因为某种原因被阻塞时，后面排队的所有请求也一起被阻塞

### HTTPS和HTTP的区别
+ 安全的超文本传输协议，基于SSL/TLS安全协议，使得报文能够加密传输
+ HTTPS三次握手后还需要进行SSL/TLS的握手过程才可以进入加密报文传输
+ HTTPS需要向CA（证书权威机构）神奇数字证书来保证服务器的身份可信

### HTTPS怎么保证安全？
**混合加密：**

1. 客户端向服务端发起加密通信请求，也就是发起握手
2. 服务端发送给客户端一个非对称加密的公匙证书
3. 客户端验证服务端的证书
4. 验证通过后客户端生成一个对称加密的会话密钥
5. 用公匙对会话密钥进行加密并将加密后的密钥发送到服务端
6. 服务端用私匙进行解密拿到会话密钥，告知客户端握手阶段结束

**摘要算法+数字签名：**

1. 通过摘要算法计算内容的哈希值，也就是内容的指纹，对方收到后也需要计算出指纹然后进行对比以确认内容是否被修改（但是内容和哈希值可能一起被修改）
2. 通过私钥对指纹进行加密以保证不会被篡改，因为如果被修改，客户端通过公钥是无法进行解密的（但是公钥也能被伪造）

**数字证书：**

1. 服务器需要将自己的公钥注册到CA（数字证书认证机构）
2. CA用自己的私钥将服务器的公钥数字签名并颁发数字证书
3. 客户端拿到服务器的数字证书后使用CA的公钥确认证书的真实性
4. 再用服务器的公钥对数据进行加密



### HTTP/1.1相比HTTP/1.0的优点
+ 长连接
+ 支持管道网络传输，只要第一个请求发出去了， 不需要等请求返回就可以继续发送第二个请求
+ <font style="color:rgb(60, 60, 67);">在请求头引入了 range 头域，它允许只请求资源的某个部分，充分利用带宽</font>
+ <font style="color:rgb(60, 60, 67);">HTTP/1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能</font>

### HTTP/2.0相比HTTP/1.1的优点
+ **多路复用（Multiplexing）**：HTTP/2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP/1.1 中长链接的升级版本），互不干扰。HTTP/1.1 则使用串行方式，每个请求和响应都需要独立的连接，而浏览器为了控制资源会有 6-8 个 TCP 连接的限制。。这使得 HTTP/2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。
+ **二进制帧（Binary Frames）**：HTTP/2.0 使用二进制帧进行数据传输，而 HTTP/1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。
+ **头部压缩（Header Compression）**：HTTP/1.1 支持`Body`压缩，`Header`不支持压缩。HTTP/2.0 支持对`Header`压缩，使用了专门为`Header`压缩而设计的 HPACK 算法，减少了网络开销。
+ **服务器推送（Server Push）**：HTTP/2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP/1.1 需要客户端自己发送请求来获取相关资源。

### HTTP/3.0相做了哪些优化
核心是改用基于UDP的QUIC协议

+ **无队头阻塞：**一<font style="color:rgb(60, 60, 67);">个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其他数据流不受影响（本质上是多路复用+轮询）。</font>
+ **更快的连接建立：**基于TLS1.3，连接建立仅需要<font style="color:rgb(60, 60, 67);">0-RTT 或者 1-RTT</font>
+ **连接迁移：** QUIC 使用 64 位 ID 标识连接，只要 ID 不变就不会中断，网络环境改变时（如从 Wi-Fi 切换到移动数据）也能保持连接。而 TCP 连接是由（源 IP，源端口，目的 IP，目的端口）组成，这个四元组中一旦有一项值发生改变，这个连接也就不能用了。
+ **更好的错误回复机制：** QUIC 可以对每个流单独进行流量控制和丢包恢复，使得在丢包发生时，影响最小化。 ** **

### 既然有HTTP协议为什么还要有RPC
+ 先出现的RPC再出现的HTTP
+ RPC（远程过程调用）不是协议，只是调用方式，比如gRPC才是协议
+ RPC适用于自己公司的客户端调用自家服务器的方法，但是在网络上大部分都是需要访问其他公司的网站服务器，这时候RPC就不太适用了，大家需要统一访问的标准才能访问，因此出现了HTTP
+ 主流的HTTP/1.1的头部在某些情况下比较冗余，且使用Json格式来序列化结构体数据，而RPC可以采用体积更小的ProtoBuf或者其他序列化协议来保存对象，也不用考虑复杂的网络行为，比如网络重定向，所以性能比HTTP/1.1要好一些
+ 但是HTTP/2.0的性能要更好，不过出来的比较晚，许多公司的RPC服务已经跑了好几年了所以也没必要换

### 既然有HTTP协议为什么还要有WebSocket
+ WebSocket 是一种双向实时通信协议，而 HTTP 是一种单向通信协议。并且，HTTP 协议下的通信只能由客户端发起，服务器无法主动通知客户端。
+ WebSocket 使用 ws:// 或 wss://（使用 SSL/TLS 加密后的协议，类似于 HTTP 和 HTTPS 的关系） 作为协议前缀，HTTP 使用 http:// 或 https:// 作为协议前缀。
+ WebSocket 可以支持扩展，用户可以扩展协议，实现部分自定义的子协议，如支持压缩、加密等。
+ WebSocket 通信数据格式比较轻量，用于协议控制的数据包头部相对较小，网络开销小，而 HTTP 通信每次都要携带完整的头部，网络开销较大（HTTP/2.0 使用二进制帧进行数据传输，还支持头部压缩，减少了网络开销）。

WebSocket 的工作过程可以分为以下几个步骤：

1. 客户端向服务器发送一个 HTTP 请求，请求头中包含 `Upgrade: websocket` 和 `Sec-WebSocket-Key` 等字段，表示要求升级协议为 WebSocket；
2. 服务器收到这个请求后，会进行升级协议的操作，如果支持 WebSocket，它将回复一个 HTTP 101 状态码，响应头中包含 ，`Connection: Upgrade`和 `Sec-WebSocket-Accept: xxx` 等字段、表示成功升级到 WebSocket 协议。
3. 客户端和服务器之间建立了一个 WebSocket 连接，可以进行双向的数据传输。数据以帧（frames）的形式进行传送，WebSocket 的每条消息可能会被切分成多个数据帧（最小单位）。发送端会将消息切割成多个帧发送给接收端，接收端接收消息帧，并将关联的帧重新组装成完整的消息。
4. 客户端或服务器可以主动发送一个关闭帧，表示要断开连接。另一方收到后，也会回复一个关闭帧，然后双方关闭 TCP 连接。

---

著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：https://javaguide.cn/cs-basics/network/other-network-questions.html

