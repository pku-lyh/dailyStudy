## 硬件结构
### 冯诺依曼模型
运算器、控制器、存储器、输入设备、输出设备

## 操作系统结构
## 内存管理
### 为什么要有虚拟内存
**虚拟内存(Virtual Memory)** 是计算机系统内存管理非常重要的一个技术，本质上来说它只是逻辑存在的，是一个假想出来的内存空间，主要作用是作为进程访问主存（物理内存）的桥梁并简化内存管理。

![](https://cdn.nlark.com/yuque/0/2024/png/39185937/1735635953084-b508326e-68a3-4ab4-be50-8a6ca31baa4e.png)

总结来说，虚拟内存主要提供了下面这些能力：

+ **隔离进程**：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。
+ **提升物理内存利用率**：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。
+ **简化内存管理**：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。
+ **多个进程共享物理内存**：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。
+ **提高内存使用安全性**：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。
+ **提供更大的可使用内存空间**：可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。

### 分段机制
**分段机制（Segmentation）** 以段(一段 **连续** 的物理内存)的形式管理/分配物理内存。应用程序的虚拟地址空间被分为大小不等的段，段是有实际意义的，每个段定义了一组逻辑信息，例如有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。

段号+段内偏移量  内存外部碎片



### <font style="color:rgb(60, 60, 67);">分页机制</font>
**<font style="color:rgb(60, 60, 67);">分页机制（Paging）</font>**<font style="color:rgb(60, 60, 67);"> 把主存（物理内存）分为连续等长的物理页，应用程序的虚拟地址空间划也被分为连续等长的虚拟页。现代操作系统广泛采用分页机制。</font>

页号+页内偏移量 内存内部碎片

**快表（TLB）：**

使用 TLB 之后的地址翻译流程是这样的：

1. 用虚拟地址中的虚拟页号作为 key 去 TLB 中查询；
2. 如果能查到对应的物理页的话，就不用再查询页表了，这种情况称为 TLB 命中（TLB hit)。
3. 如果不能查到对应的物理页的话，还是需要去查询主存中的页表，同时将页表中的该映射表项添加到 TLB 中，这种情况称为 TLB 未命中（TLB miss)。
4. 当 TLB 填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。

### 分页机制和分段机制有哪些共同点和区别？
**共同点**：

+ 都是非连续内存管理的方式。
+ 都采用了地址映射的方法，将虚拟地址映射到物理地址，以实现对内存的管理和保护。

**区别**：

+ 分页机制以页面为单位进行内存管理，而分段机制以段为单位进行内存管理。页的大小是固定的，由操作系统决定，通常为 2 的幂次方。而段的大小不固定，取决于我们当前运行的程序。
+ 页是物理单位，即操作系统将物理内存划分成固定大小的页面，每个页面的大小通常是 2 的幂次方，例如 4KB、8KB 等等。而段则是逻辑单位，是为了满足程序对内存空间的逻辑需求而设计的，通常根据程序中数据和代码的逻辑结构来划分。
+ 分段机制容易出现外部内存碎片，即在段与段之间留下碎片空间(不足以映射给虚拟地址空间中的段)。分页机制解决了外部内存碎片的问题，但仍然可能会出现内部内存碎片。
+ 分页机制采用了页表来完成虚拟地址到物理地址的映射，页表通过一级页表和二级页表来实现多级映射；而分段机制则采用了段表来完成虚拟地址到物理地址的映射，每个段表项中记录了该段的起始地址和长度信息。
+ 分页机制对程序没有任何要求，程序只需要按照虚拟地址进行访问即可；而分段机制需要程序员将程序分为多个段，并且显式地使用段寄存器来访问不同的段。

### <font style="color:rgb(60, 60, 67);">段页机制</font>
<font style="color:rgb(60, 60, 67);">结合了段式管理和页式管理的一种内存管理机制，把物理内存先分成若干段，每个段又继续分成若干大小相等的页。</font>

<font style="color:rgb(60, 60, 67);">在段页式机制下，地址翻译的过程分为两个步骤：</font>

1. <font style="color:rgb(60, 60, 67);">段式地址映射。</font>
2. <font style="color:rgb(60, 60, 67);">页式地址映射。</font>

###  内存满了之后会有什么处理  
#### 1. 使用交换空间 (Swap)
+ **概念**: 如果物理内存耗尽，操作系统会将部分内存数据写入磁盘上的交换分区或交换文件，以释放内存。
+ **优缺点**:
    - **优点**: 提供了额外的虚拟内存，防止程序因内存不足崩溃。
    - **缺点**: 交换空间速度远慢于物理内存，可能导致系统性能显著下降（俗称“变卡”或“换页风暴”）。

#### 2. 触发内存回收 (Memory Reclamation)
+ **机制**: 操作系统会尝试回收不活跃的内存，比如清理缓存或释放未使用的页面。
+ **优缺点**:
    - **优点**: 可以迅速释放部分内存。
    - **缺点**: 回收可能会影响部分正在运行的低优先级进程的性能。

#### 3. 触发 OOM Killer（Out-Of-Memory Killer）
+ **概念**: 在 Linux 等系统中，如果内存和交换空间都耗尽，内核会启动 OOM Killer 机制，强制终止某些进程。
+ **选择目标进程**:
    - 通常会选择内存占用较大的进程。
    - 使用特定策略（如 `oom_score`）判断哪个进程“优先被杀”。
+ **后果**:
    - 某些进程可能被强制关闭，导致数据丢失或服务中断。

### 如何避免预读失败和缓存污染的问题
## 进程管理
## 调度算法
## 文件系统
## 设备管理
## 网络系统
## Linux命令
